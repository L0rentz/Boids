#version 460 core

#define BUCKETS_COUNT 100
#define GRID_WIDTH sqrt(BUCKETS_COUNT)

#define PI 3.1415926538

#define COHESION 100.0f
#define ALIGNMENT 75.0f
#define SEPARATION 100.0f
#define FOV 260
#define ROTATION_SPEED 4
#define SPEED 1


layout (local_size_x = 32) in;

struct s_hash {
    float size;
    float startIdx;
};

struct s_boid {
    float centerX;
    float centerY;
    float scaleX;
    float scaleY;
    float angleDeg;
    float hashKey;
};

layout(std430, binding = 0) buffer sharedBufferBoids {
    s_hash htable[BUCKETS_COUNT];
    float boidsCount;
    float windowWidth;
    float windowHeight;
    float bufferSelector;
    s_boid boids[];
};

void checkBorder(const int thisBoid)
{
    if (boids[thisBoid].centerX > windowWidth)
        boids[thisBoid].centerX = 0;
    if (boids[thisBoid].centerX < 0)
        boids[thisBoid].centerX = windowWidth;

    if (boids[thisBoid].centerY > windowHeight)
        boids[thisBoid].centerY = 0;
    if (boids[thisBoid].centerY < 0)
        boids[thisBoid].centerY = windowHeight;
}

float magnitudeVec2(const vec2 a, const vec2 b)
{
    return sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2));
}

vec2 getBoidDirection(const float angleDeg, const float len) {
    float angleRad = (angleDeg - 90) * PI / 180;
    return vec2(len * cos(angleRad), len * sin(angleRad));
}

// void checkAllNeighbours()
// {
//     for (int i = startIdx; i < maxIdx; i++) {
//         if (i == thisBoid) continue;
//         if (magnitudeVec2(vec2(boids[i].centerX, boids[i].centerY), vec2(boids[thisBoid].centerX, boids[thisBoid].centerY)) < maxRange) {
//             boids[i].centerY += 2.0;
//         }
//     }
// }

vec2 normalizeVec2(const vec2 a, const vec2 b)
{
    float magnitude = magnitudeVec2(a, b);
    vec2 direction = vec2(a.x - b.x, a.y - b.y);
    vec2 normalize = direction;

    normalize.x /= magnitude;
    normalize.y /= magnitude;

    return normalize;
}

int mappedRadToDeg(float rad)
{
    float deg = rad * (180.0 / PI);
    return int(deg + 360) % 360;
}

void processRotation(const vec2 point, vec2 thisBoidCenter, vec2 thisBoidDirection, int thisBoid)
{
    vec2 normalizedDirection = normalizeVec2(thisBoidCenter, point);
    vec2 normalizedBoidDirection = normalizeVec2(thisBoidCenter, thisBoidDirection);

    float angleDirection = atan(normalizedDirection.x, normalizedDirection.y);
    float angleBoid = atan(normalizedBoidDirection.x, normalizedBoidDirection.y);

    int mappedDirectionDegrees = mappedRadToDeg(angleDirection);
    int mappedBoidDegrees = mappedRadToDeg(angleBoid);
    int degreesDif = mappedDirectionDegrees - mappedBoidDegrees;

    if (abs(degreesDif) <= ROTATION_SPEED * 5) return;
    int tmpRotationSpeed = ROTATION_SPEED * -1;
    if (mappedDirectionDegrees < mappedBoidDegrees && mappedBoidDegrees - mappedDirectionDegrees <= 180) tmpRotationSpeed *= -1;
    if (mappedDirectionDegrees > mappedBoidDegrees && mappedDirectionDegrees- mappedBoidDegrees > 180) tmpRotationSpeed *= -1;
    boids[thisBoid].angleDeg += tmpRotationSpeed;
}

void main()
{
    if (gl_GlobalInvocationID.x >= boidsCount) return;

    int thisBoid = int(gl_GlobalInvocationID.x);
    if (bufferSelector == 2.0f) thisBoid += int(boidsCount);

    int startIdx = int(htable[int(boids[gl_GlobalInvocationID.x].hashKey)].startIdx);
    if (bufferSelector == 2.0f) startIdx += int(boidsCount);
    int maxIdx = startIdx + int(htable[int(boids[gl_GlobalInvocationID.x].hashKey)].size);

    float maxRange = COHESION > ALIGNMENT ? COHESION > SEPARATION ? COHESION : SEPARATION : ALIGNMENT > SEPARATION ? ALIGNMENT : SEPARATION;

    vec2 directionVec = getBoidDirection(boids[thisBoid].angleDeg, SPEED);
    boids[thisBoid].centerX += directionVec.x;
    boids[thisBoid].centerY += directionVec.y;

    // vec2 separationVec = vec2(0, 0);
    // int sepCount = 0;
    // vec2 cohesionVec = vec2(0, 0);
    // vec2 alignementVec = vec2(0, 0);

    // for (int i = startIdx; i < maxIdx; i++) {
    //     if (i == thisBoid) continue;
    //     if (magnitudeVec2(vec2(boids[i].centerX, boids[i].centerY), vec2(boids[thisBoid].centerX, boids[thisBoid].centerY)) < SEPARATION) {
    //         separationVec += vec2(boids[i].centerX, boids[i].centerY);
    //         sepCount++;
    //     }
    // }
    // separationVec.x = (separationVec.x / sepCount - boids[thisBoid].centerX) * -1 + boids[thisBoid].centerX;
    // separationVec.y = (separationVec.y / sepCount - boids[thisBoid].centerY) * -1 + boids[thisBoid].centerY;
    // if (length(separationVec) > 0)
    //     processRotation(separationVec, vec2(boids[thisBoid].centerX, boids[thisBoid].centerY), directionVec, thisBoid);

    checkBorder(startIdx);
}